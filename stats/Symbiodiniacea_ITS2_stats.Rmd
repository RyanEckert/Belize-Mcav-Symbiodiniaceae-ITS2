---
title: "Symbiodiniaceae *ITS2* community analyses"
author: "Ryan Eckert -- ryan.j.eckert@gmail.com"
date: "version: 10/17/2019"
output:
  html_document:
    theme: flatly
    code_folding: show
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---
<br>

#About this document
This is the code accompanies the publication **Eckert RJ, Reaume A, Sturm AB, Studivan MS, and Voss JD.(in review) Symbiodiniaceae community variation among Montastraea cavernosa populations along a depth gradient on the Belize Barrier Reef.** Here you will find all the code to repeat the statistical analyses performed for this manuscript. All of the accompanying data can be found on my [github](https://github.com/RyanEckert/Symbiodiniaceae-ITS2/stats).  

If you download my entire accompanying github directory you should be able to re-run these analyses by following along with the included code in R Studio. If you download the code separtely or you are using this pipeline on your own data, you may need to change the working directory to whereever the associated files are housed (ie. ```setwd("~/path/to/directory/with/data")```).  
  
The data used for this analysis are OTUs calculated with R packages *dada2* and *LULU*. The raw Symbiodiniaceae *ITS2* sequences obtained from *Montastraea cavernosa* samples can be found in the NCBI SRA under project number XXX <XXX>. Hopefully you are able to follow along this file and find it useful to use with your own data!<br>

Additional data and walkthroughs:<br>

*[Library preparation](https://ryaneckert.github.io/Symbiodiniaceae-ITS2/lab_protocol)
<br>
*[Sequence trimming and filetering](https://ryaneckert.github.io/Symbiodiniaceae-ITS2/seq_processing)
<br>
*[OTU calculation](https://ryaneckert.github.io/Symbiodiniaceae-ITS2/dada_lulu)
<br><br>

#Basic setup of R environment and data
<br>

##Loading required packages
For the following analyses we will require the use of a number of different R packages. Most of these can be sourced from CRAN, but a couple need to be downloaded from GitHub or BioConducter. We can use the following code to quickly load in the packages and install any packages not previously installed in the R console.
```{r, setup, include = FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

```{r, load packages, include = TRUE, warning = TRUE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load("BiocManager", "car", "cluster", "dunn.test", "edgeR", "ggpubr", "labdsv", 
               "MCMC.OTU", "multcompView", "pgirmess", "plyr", "reshape", "vegan")

pacman::p_load_gh("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")

if (!require("edgeR")){BiocManager::install("edgeR", update = FALSE) 
  library(edgeR)}
```

##Creating a color palette to use for our data
We need 10 colors, I'm using mostly ggPlot colors, but in a better order for visualizing our OTU bar chart. I like to set a default palette at the beginning and call specific colors from it as needed throughout.
```{r, color palette}
its2ColPal=c("#0081EF", "#00B0F6", "#00BFC4", "#39B600", "#9590FF", "#E76BF3", "#FF62BC",
             "#F8766D", "#D89000", "#A3A500")
```

```{r, palette, echo = FALSE, fig.align = 'center'}
#This is what the palette looks like in sequence
pie(rep(1,length(its2ColPal)), col = its2ColPal)
```

##Loading our data into R
First, we need to load in the data from dada2 and LULU analyses.
```{r, dada2 and LULU data, results='hide'}

curated_result_97 = readRDS("curated_result_97.rds") #read in LULU output
ITS2data <- read.csv("ASVtable.csv") #read in dada2 output
head(ITS2data)
```
<br><br>

#Preparing data for analyses
Now that the data are loaded in, we can continue to make these data the way we need them for our analyses. We can combine our curated OTUs with the metadata we added to our ASV file.
```{r, combine OTU data and sample metadata}
ITS2data = cbind(ITS2data[, 1:3], data.frame(t(curated_result_97$curated_table)))
```
And we can order sites from north to south so later data can be plotted shallow to deep; north to south. To do this we can set "Depth" and "Site" as factors 
```{r, order site and depth factors}
ITS2data$Depth = factor(ITS2data$Depth, levels = c("10", "16", "25", "35"))
levels(ITS2data$Site)
ITS2data$Site = factor(ITS2data$Site, levels(ITS2data$Site)[c(4, 2, 3, 1)])
ITS2data = ITS2data[order(ITS2data$Site, ITS2data$Depth), ]
ITS2data$newOrder = 1:nrow(ITS2data)
ITS2data = cbind(ITS2data[, length(ITS2data), drop = FALSE], 
                 ITS2data[, c(1:length(ITS2data) - 1)])
row.names(ITS2data) = ITS2data$Sample
head(ITS2data)
```
Now we can call these data for the following analyses.
<br>

##Purging outlying OTUs
```{r, purging outlying OTUs}
goods = purgeOutliers(ITS2data, count.columns = 5:length(ITS2data), otu.cut = 0.001)
goods$newOrder = 1:nrow(goods)
row.names(goods) = goods$sample
head(goods)
row.names(goods) = goods$sample
```

##Samples with data for OTUs
What is the proportion of samples with data for these OTUs?
```{r, proportion of good otus, tidy = TRUE}
withData = apply(goods[, 5:length(goods[1, ])], 2, function(x) {
  sum(x > 0) / length(x)
})
hist(withData, breaks = 50)

props = apply(goods[, 5:length(goods[1, ])], 2, function(x) {
  sum(x) / sum(goods[, 5:length(goods[1, ])])
})

props

barplot(props, xaxt = "n", log = "y")
```

##Normalizing reads across all samples
Here we normalize OTU counts with weighted trimmed mean of M-values (TMM; Robinson and Oshlack 2010; <https://doi.org/10.1186/gb-2010-11-3-r25>). This helps to account for disparity in sequencing depth across libraries.
First we transpose the data to work with *edgeR*
```{r, transpose data}
itsGoodsTransposed = t(goods[, 5:length(goods[1, ])])
itsGoodsList = DGEList(counts = itsGoodsTransposed)
head(itsGoodsList$samples)
```

Now we can use TMM normalization in *edgeR*
```{r, edgeR TMM normalization}
its2Norm =  calcNormFactors(itsGoodsList, method = "TMM")
head(its2Norm$samples)
its2TMM = t(cpm(its2Norm, normalized.lib.sizes = TRUE))
its2Norm = cbind(goods[,c(2:4)], its2TMM)
head(its2Norm)
```
<br>

##Renaming OTU sequence columns
Finally, I want to rename the columns with the Symbiodiniaceae sequences identified through our previose BLASTn query

```{r, rename OTU columns}
colnames(its2Norm)[4:ncol(its2Norm)] = c("sq01_C3", "sq10_C3", "sq11_C3g", "sq14_C3g",
                                         "sq17_C3g", "sq18_C3g", "sq25_C3g", "sq05_C3z",
                                         "sq07_C3e", "sq08_C3g")
head(its2Norm)
levels(its2Norm$Site)
levels(its2Norm$Depth)
```
After all that everything looks good to go. On to the fun stuff!
<br><br>

#OTU $\alpha$-diversity
Looking at $\alpha$-diversity of Symbiodiniaceae OTU sequences in each of our samples for comparison. We will look at species richness, Shannon's index and Simpson's index
<br>

##Calculate $\alpha$-diversity metrics
```{r, alpha diversity calculation}
its2Richness = specnumber(its2Norm[,4:ncol(its2Norm)])
its2Shannon = diversity(its2Norm[,4:ncol(its2Norm)],index = "shannon")
its2Simpson = diversity(its2Norm[,4:ncol(its2Norm)],index = "simpson")
its2Div = cbind(its2Norm[,1:3], its2Richness, its2Shannon, its2Simpson)
colnames(its2Div)[4:6] = c("richness", "shannon", "simpson")
head(its2Div)
```
<br>

##Statistical tests of $\alpha$-diversity
Now we can test whether or not there a significant differences in any of the calculated $\alpha$-diversity metrics across Site or Depth.
<br>

###Assumption testing
First we need to see if our data are normally distributed. We can use Shapiro-Wilk's test.
```{r, shapiro-wilk test}
tapply(its2Div$richness, its2Div$Site, shapiro.test)
tapply(its2Div$shannon, its2Div$Site, shapiro.test)
tapply(its2Div$simpson, its2Div$Site, shapiro.test)
tapply(its2Div$richness, its2Div$Depth, shapiro.test)
tapply(its2Div$shannon, its2Div$Depth, shapiro.test)
tapply(its2Div$simpson, its2Div$Depth, shapiro.test)
```
We see that our data are NOT normally distributed.<br>

We can use Levene's test to test for equal variance among sites and depths.
```{r, levenes test}
leveneTest(its2Div$richness, its2Div$Depth)
leveneTest(its2Div$shannon, its2Div$Depth)
leveneTest(its2Div$simpson, its2Div$Depth)
leveneTest(its2Div$richness, its2Div$Site)
leveneTest(its2Div$shannon, its2Div$Site)    
leveneTest(its2Div$simpson, its2Div$Site)
```
Data are non-normally distributed and also heteroschedastic. 
Using non-parametric tests moving forward.<br>

##Kruskal-Wallis Tests
Since our data did not fit the assumptions of ANOVA, we will use single factor Krskal-Wallis tests on these data.
<br>

###K-W test on Shannon's indices
```{r, k-w shannon}
kruskal.test(shannon ~ Site, data = its2Div)
kruskal.test(shannon ~ Depth, data = its2Div)
```
Nothing significant
<br>

###K-W test on Simpson's indices
```{r, k-w simpson}
kruskal.test(simpson ~ Site, data = its2Div)
kruskal.test(simpson ~ Depth, data = its2Div)
```
Again, no significant tests.
<br>

###K-W test on species richness
```{r, k-w richness}
kruskal.test(richness ~ Site, data = its2Div)
kruskal.test(richness ~ Depth, data = its2Div)
```
Here we see that species richness changes significantly with Depth.
<br>

##Pairwise comparisons with Dunn's test
We now use Dunn's test to do multiple comparisons with bonferroni correction. This will reveal where the differences in species richness are across Depth
```{r, dunns test}
dunn.test(its2Div$richness, g = its2Div$Depth, method = "bonferroni", table = FALSE, 
          list = TRUE)
```
This shows us that species richness is different between our deepest sites and our shallowest sites.
<br>

##Plotting $\alpha$-diversity metrics
We can take all of our $\alpha$-diversity metrics and plot them all into a single figure panel to visualize the results of the previous tests. Here we make plots for richness, Simpson's and Shannon's indices by site and depth zone.
<br>

###Plot species richness by site
```{r, Plotting species richness by site, fig.show = 'hide'}
its2RichPlotS = ggplot(data = its2Div, aes(x = Site, y = richness)) +
                geom_point(aes(fill = Depth),shape = 21, color = "gray20", size = 2,
                           position = position_jitterdodge()) +
                geom_boxplot(alpha = 0, outlier.shape = NA, color = "gray30") +
                scale_fill_manual(values = its2ColPal[c(1, 4, 6, 2)],
                                  labels = c("10 m", "16 m", "25 m", "35 m")) +
                xlab("Reef Site") +
                ylab("Richness") +
                stat_compare_means(size = 5, geom = "label", label.x = 1, label.y = 10.7) +
                coord_cartesian(ylim = c(1, 11)) +
                scale_y_continuous(breaks = seq(2, 10, 2)) +
                guides(fill = guide_legend(ncol = 2)) +
                theme_bw()

its2RichPlotSite = its2RichPlotS +
                   theme(axis.title.x = element_blank(),
                         axis.text.x = element_blank(),
                         axis.title.y = element_text(color = "black", size = 14),
                         axis.text.y = element_text(color = "black", size = 12),
                         legend.title = element_text(color = "black", size = 14),
                         legend.text = element_text(color = "black", size = 12),
                         panel.border = element_rect(size = 1.1, color = "black"),
                         panel.background = element_rect(fill = "white"),
                         plot.background = element_rect(fill = "white"),
                         legend.position = "bottom",
                         legend.background = element_rect(color = "black"),
                         plot.margin = unit(c(0.5, 0.1, 0.1, 0.61), "cm")
                         )

its2RichPlotSite
```
<br>

###Create pairwise comparison letters
We know from our Kruskal-Wallis tests that there was a significant difference in the species diversity across depth zones. We can plot letters to denote similarity between groups on our plot.
```{r, pairwise comparison plot}
richDkmc = kruskalmc(its2Div$richness ~ its2Div$Depth) # multiple-comparison test
print(richDkmc)

richDkmcDiff = richDkmc$dif.com$difference # select logical vector
names(richDkmcDiff) = row.names(richDkmc$dif.com)# add comparison names

# create a list with "homogenous groups" coded by letter
richDsigLetters = multcompLetters(richDkmcDiff, compare="<", threshold=0.05, 
                                  Letters=c(letters, LETTERS, "."), reversed = FALSE)
richLetters = as.data.frame(richDsigLetters$Letters)
richLetters$depth = row.names(richLetters)
colnames(richLetters)[1] = "id"
richLetters$y = c(1, 1, 1, 1)
head(richLetters)
```
These letters can now be added to the corresponding plot.
<br>

###Plot species richness by depth
```{r, plotting species richness by depth, fig.show = 'hide'}
its2RichPlotD = ggplot(data = its2Div, aes(x = Depth, y = richness)) +
                geom_point(aes(fill = Site), shape = 21, color = "gray 20", size = 2,
                          position = position_jitterdodge()) +
                geom_boxplot(alpha = 0, outlier.shape = NA, color = "gray30") +
                scale_fill_manual(values = its2ColPal[c(8,5,3,9)], 
                                  labels = c("Tobacco Reef", "Raph's Wall", 
                                            "South Reef", "Gover's Reef")) +
                stat_compare_means(size = 5, geom = "label", label.x = 1.07, 
                                  label.y = 10.7) +
                geom_text(data = richLetters, aes(x = depth, y = y, label = id), 
                          size = 6) + 
                coord_cartesian( ylim = c(1, 11)) +
                scale_y_continuous(breaks = seq(2, 10, 2))+
                xlab("Depth (m)") +
                ylab("Richness") +
                guides(fill=guide_legend(ncol=2))+
                theme_bw()

its2RichPlotDepth = its2RichPlotD +
                     theme(axis.title.x = element_blank(),
                           axis.text.x = element_blank(),
                           axis.title.y = element_blank(),
                           axis.text.y = element_blank(),
                           legend.title = element_text(color = "black", size = 14),
                           legend.text = element_text(color = "black", size = 12),
                           panel.border = element_rect(size = 1.1, color = "black"),
                           panel.background = element_rect(fill = "white"),
                           plot.background = element_rect(fill = "white"),
                           legend.position = "bottom",
                           legend.background = element_rect(color = "black"),
                           plot.margin = unit(c(0.5, 0.5, 0.1, 0.85), "cm")
                           )
its2RichPlotDepth
```
<br>

###Make legends grobs
Now we want to take the Site and Depth legends and make them graphical objects (grobs). This will allow us to place them separately in our figure grid, so each plot won't have its own legend.
```{r, make site legend a grob, results = 'hide', fig.show = 'hide'}
get_legend <- function(its2RichPlotSite) {
  tmp <- ggplot_gtable(ggplot_build(its2RichPlotSite))
  leg <-
  which(sapply(tmp$grobs, function(x)
  x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

legend.site = get_legend(its2RichPlotSite)

get_legend = function(its2RichPlotDepth) {
  tmp <- ggplot_gtable(ggplot_build(its2RichPlotDepth))
  leg <-
  which(sapply(tmp$grobs, function(x)
  x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

legend.depth = get_legend(its2RichPlotDepth)

# re-plot without legends
its2RichPlotSite = its2RichPlotSite + theme(legend.position = "none")
its2RichPlotDepth = its2RichPlotDepth + theme(legend.position = "none")
```
<br>

###Plot Shannon's index by site
```{r, plot shannons index by site, fig.show = 'hide'}
its2ShannonPlotS = ggplot(data = its2Div, aes(x = Site, y = shannon)) +
                   geom_point(aes(fill = Depth), shape = 21, color = "gray20", 
                              size = 2, position = position_jitterdodge()) +
                   geom_boxplot(alpha = 0, outlier.shape = NA, color = "gray30") +
                   scale_fill_manual(values = its2ColPal[c(1, 4, 6, 2)],
                                     labels = c("10 m", "16 m", "25 m", "35 m")) +
                   stat_compare_means(size = 5, geom = "label", label.x = 1, 
                                      label.y = 1.7) +
                   expand_limits(y = c(0, 1.75)) +
                   xlab("Reef Site") +
                   ylab("Shannon's index") +
                   theme_bw()

its2ShannonPlotSite = its2ShannonPlotS + 
                      theme(axis.title.x = element_blank(),
                            axis.text.x = element_blank(),
                            axis.title.y = element_text(color = "black", size = 14),
                            axis.text.y = element_text(color = "black", size = 12),
                            legend.title = element_text(color = "black", size = 14),
                            legend.text = element_text(color = "black", size = 12),
                            panel.border = element_rect(size = 1.1, color = "black"),
                            panel.background = element_rect(fill = "white"),
                            plot.background = element_rect(fill = "white"),
                            legend.position = "none",
                            legend.background = element_rect(color = "black"),
                            plot.margin = unit(c(0.1, 0.1, 0.1, 0.5), "cm")
                            )

its2ShannonPlotSite
```
<br>

###Plot Shannon's index by depth
```{r, plot shannons index by depth, fig.show = 'hide'}
its2ShannonPlotD = ggplot(data = its2Div, aes(x = Depth, y = shannon))+
                   geom_point(aes(fill = Site), shape = 21, color = "gray20", size = 2,
                              position = position_jitterdodge()) +
                   geom_boxplot(alpha = 0, outlier.shape = NA, color = "gray30") +	
                   scale_fill_manual(values = its2ColPal[c(8,5,3,9)], 
                                     labels = c("Tobacco Reef", "Raph's Wall", 
                                     "South Reef", "Gover's Reef")) +
                   stat_compare_means(size = 5, geom = "label", label.x = 1, 
                                      label.y = 1.7) +
                   expand_limits(y = c(0, 1.75)) +
                   xlab("Depth (m)") +
                   ylab("Shannon's index") +
                   theme_bw()

its2ShannonPlotDepth = its2ShannonPlotD + 
                       theme(axis.title.x = element_blank(),
                             axis.text.x = element_blank(),
                             axis.title.y = element_blank(),
                             axis.text.y = element_blank(),
                             legend.title = element_text(color = "black", size = 14),
                             legend.text = element_text(color = "black", size = 12),
                             panel.border = element_rect(size = 1.1, color = "black"),
                             panel.background = element_rect(fill = "white"),
                             plot.background = element_rect(fill = "white"),
                             legend.position = "none",
                             legend.background = element_rect(color = "black"),
                             plot.margin = unit(c(0.1, 0.5, 0.1, 0.85), "cm")
                             )

its2ShannonPlotDepth
```
<br>

###Plot Simpson's index by site
```{r, plot simpsons index by site, fig.show = 'hide'}
its2SimpsonPlotS = ggplot(data = its2Div, aes(x = Site, y = simpson)) +
                   geom_point(aes(fill = Depth), shape = 21, color = "gray20", size = 2,
                              position = position_jitterdodge()) +
                   geom_boxplot(alpha = 0, outlier.shape = NA) +	
                   scale_fill_manual(values = its2ColPal[c(1,4,6,2)], 
                                     labels = c("10 m", "16 m", "25 m", "35 m")) +
                   stat_compare_means(size = 5, geom = "label", label.x = 1, 
                                      label.y = 0.77) + 	
                   expand_limits(y = c(0, 0.8)) +
                   xlab("Reef Site") +
                   ylab("Simpson's index") +
                   theme_bw()

its2SimpsonPlotSite = its2SimpsonPlotS + 
                      theme(axis.title.x = element_text(color = "black", size = 14),
                            axis.text.x = element_text(color = "black", size = 12),
                            axis.title.y = element_text(color = "black", size = 14),
                            axis.text.y = element_text(color = "black", size = 12),
                            legend.title = element_text(color = "black", size = 14),
                            legend.text = element_text(color = "black", size = 12),
                            panel.border = element_rect(size = 1.1, color = "black"),
                            panel.background = element_rect(fill = "white"),
                            plot.background = element_rect(fill = "white"),
                            legend.position = "none",
                            legend.background = element_rect(color = "black"),
                            plot.margin = unit(c(0.11, 0.1, 0, 0.5), "cm")
                            )

its2SimpsonPlotSite
```
<br>

###Plot Simpson's index by depth
```{r, plot simpsons index by depth, fig.show = 'hide'}
its2SimpsonPlotD = ggplot(data = its2Div, aes(x = Depth, y = simpson)) +
                   geom_point(aes(fill = Site), shape = 21, color = "gray20", size = 2,
                              position = position_jitterdodge()) +
                   geom_boxplot(alpha = 0, outlier.shape = NA) +	
                   scale_fill_manual(values = its2ColPal[c(8,5,3,9)], 
                                     labels = c("Tobacco Reef", "Raph's Wall", 
                                     "South Reef", "Gover's Reef")) +
                   stat_compare_means(size = 5, geom = "label", label.x = 1,
                                      label.y = 0.77) + 	
                   expand_limits(y = c(0, 0.8)) +
                   xlab("Depth (m)") +
                   ylab("Simpson's index") +
                   theme_bw()

its2SimpsonPlotDepth = its2SimpsonPlotD + 
                       theme(axis.title.x = element_text(color = "black", size = 14),
                             axis.text.x = element_text(color = "black", size = 12),
                             axis.title.y = element_blank(),
                             axis.text.y = element_blank(),
                             legend.title = element_text(color = "black", size = 14),
                             legend.text = element_text(color = "black", size = 12),
                             panel.border = element_rect(size = 1.1, color = "black"),
                             panel.background = element_rect(fill = "white"),
                             plot.background = element_rect(fill = "white"),
                             legend.position = "none",
                             legend.background = element_rect(color = "black"),
                             plot.margin = unit(c(0.1, 0.5, 0, 0.85), "cm")
                             )

its2SimpsonPlotDepth
```
<br>

###Create a single figure panel
Now we want to throw all those bad boys into a single figure grid.
```{r, create a figure grid from all the alpha plots, fig.show = 'hide'}
divPlots = ggarrange(its2RichPlotSite, its2RichPlotDepth, its2ShannonPlotSite, 
                     its2ShannonPlotDepth, its2SimpsonPlotSite, its2SimpsonPlotDepth,
                     legend.site, legend.depth, ncol = 2, nrow = 4, widths = c(3.5,3.4),
                     heights = c(3,3,3.4,1), 
                     labels = c("a","b", "c", "d", "e", "f","",""),
                     font.label = list(size = 18, color = "black", face ="bold")
                     )

divPlots
```
<br>

###Save as high-res images
Finally, we will save the resulting $\alpha$-diversity plot panel as a high resoultion .eps figure. Alternatively you could save it as a HQ .tiff by simply changing the extension in the code below. 
```{r, save alpha plots as eps}
ggsave("its2_diversityPlots.eps", plot = divPlots, width = 8.25, height = 10, 
       unit = "in", dpi = 600)
```

```{r, resulting alpha plot figure panel, echo = FALSE, fig.width = 7.75, fig.height = 9.25, fig.align = 'center', results = 'hide'}
plot(divPlots)
```
<br><br>

#Ordination with PCoA
We can use principal coordinates analysis (PCoA) to visualize our samples based on significant OTUs.
But, first we need to set up data for PCoA analysis in R.
<br>

##Create distance matrix
We will create a distance matrix with Bray-Curtis similarity using the package *vegan*
```{r, create distance matrix}
its2Dist = vegdist(its2Norm[, c(4:ncol(its2Norm))], method = "bray")
```
<br>

##Perform PCoA
This is the actual PCoA step
```{r, calculate PCoA}
its2Mds = cmdscale(its2Dist, eig = TRUE, x.ret = TRUE)
```
<br>

##Determine percent variation captured on each axis 
Calculate the eigenvalues so later we can figure out % variation shown on each Principal Coordinate
```{r, calculate eigenvalues}
its2Var = round(its2Mds$eig/sum(its2Mds$eig)*100, 1)
its2Var
```
<br>

##Format data to plot
```{r, format pcoa to plot}
its2Values = its2Mds$points

its2Values =as.data.frame(its2Values, sample = rownames(its2Values))
its2Pcoa = data.frame(sample = rownames(its2Values), site = as.factor(its2Norm$Site),
                      depth = as.factor(its2Norm$Depth),PCo1 = its2Values[,1],
                      PCo2 = its2Values[,2])

head(its2Pcoa)
```
<br>

##PCoA biplot
```{r, plot PCoA, fig.show = 'hide'}
its2PcoaA = ggplot(its2Pcoa, aes(x = PCo1, y = PCo2)) +
            geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
            geom_vline(xintercept = 0, color = "gray90", size = 0.5) + 
            geom_point(aes(shape = factor(depth), size = depth, fill = site), 
                       color = "black") +
            scale_fill_manual(values = its2ColPal[c(8,5,3,9)], name = "Reef Site", 
            	                labels = c("Tobacco Reef", "Raph's Wall", "South Reef",
            	                           "Glover's Reef")) +
          	scale_shape_manual(values = c(24,23,22,21), name = "Depth",
                               labels = c("10 m", "16 m", "25 m", "35 m")) +
          	scale_size_manual(values = c(4, 4.75, 4.75, 4.75)) + 
          	guides(shape = guide_legend(override.aes = list(size = c(4, 4.75, 4.75, 4.75), 
          	       fill = "white")), fill = guide_legend(override.aes = 
                   list(shape = 22, size = 5.75, color = "white")),	size = FALSE, 
          	       color = FALSE)+
          	 xlab(paste ("PCo 1 (", its2Var[1],"%)", sep = "")) +
          	 ylab(paste ("PCo 2 (", its2Var[2],"%)", sep = "")) +
          	 theme_bw()

its2Pcoa = its2PcoaA + 
           theme(axis.title.x = element_text(color = "black", size = 12),
                 axis.text.x = element_blank(),
                 axis.ticks.x = element_blank(),
                 axis.line.x = element_blank(),
                 axis.title.y = element_text(color = "black", size = 12),
                 axis.text.y = element_blank(),
                 axis.ticks.y = element_blank(),
                 axis.line.y = element_blank(),
                 legend.position = "right",
                 legend.title = element_text(color = "black", size = 12),
                 legend.text = element_text(color = "black", size = 12),
                 legend.key = element_blank(),
                 panel.border = element_rect(color = "black", size = 1.2),
                 panel.background = element_rect(fill = "white"),
                 plot.background = element_rect(fill = "white"),
                 panel.grid.major = element_blank(),
                 panel.grid.minor = element_blank()
                 )

its2PcoaA
```
<br>

##Save the generated PCoA plot
```{r, save pcoa plot, fig.show = 'hide'}
ggsave("ITS2_OTU_PCoA.eps", plot = its2Pcoa, width = 10, height = 6.25, dpi = 600,
       device="eps")
```

```{r, pcoa plot, echo = FALSE, fig.width = 8, fig.height = 5, fig.align = 'center'}
plot(its2Pcoa)
```
<br><br>

#Ordination with nMDS
Now we can view the data with nMDS using the package *vegan* again.
First we have to run the calculations for the nMDS. 
This is similar to PCoA, but can be scaled freely and uses an iterative process.
We'll run it with 50 iterations, which should be enough to arrive at a solution.
```{r, nmds, results = 'hide'}
set.seed(694)
its2Nmds = metaMDS(its2Norm[4:ncol(its2Norm)], try = 50)
its2Nmds
```
<br>

##Prepare data to plot
```{r, nmds data prep for plotting}
its2Scores = as.data.frame(scores(its2Nmds))
its2Scores$site = factor(its2Norm$Site)
its2Scores$depth = as.factor(its2Norm$Depth)
its2Scores$sample = row.names(its2Scores)
head(its2Scores)

its2Clades = as.data.frame(scores(its2Nmds,"species"))
its2Clades$seq = row.names(its2Clades)
its2Clades
its2Clades$seq
```
<br>

##Construct nMDS biplot
```{r, nmds biplot, fig.show = 'hide'}
its2NmdsPlotA = ggplot() + 
  	            geom_point(data = its2Scores, aes(x = NMDS1, y = NMDS2, 
  	                       shape = depth, size = depth, fill = site), 
  	                       color = "black") + # add the site points	
                scale_fill_manual(values = its2ColPal[c(8,5,3,9)], 
                                  name = "Reef Site", labels = c("Tobacco Reef",
                                  "Raph's Wall", "South Reef", "Glover's Reef")) +
              	scale_shape_manual(values = c(24, 23, 22, 21), name = "Depth", 
              	                   labels = c("10 m", "16 m", "25 m", "35 m")) +
              	scale_size_manual(values = c(3, 3.75, 3.75, 3.75)) + 
              	guides(shape = guide_legend( override.aes = list(size = 
              	       c(3, 3.75, 3.75, 3.75), fill = "white")), fill =
              		     guide_legend(override.aes = list(shape = 22, size = 3.75, 
              		     color = NA)), size = FALSE)+
              	geom_text(data = its2Clades, aes(x = NMDS1, y = NMDS2,
              	                                 label = seq), 
              		        color = "#000000", size = 4, fontface = "italic") +  
                          # add seq labels	
              	annotate("label", x = 1.25, y = 0.725, label = paste 
              		        ("Distance = Bray-Curtis\nStress = ", 
              		        round(its2Nmds$stress, 4), sep = ""), size = 4) +
                labs(x = "nMDS1", y = "nMDS2") +
              	coord_equal() +
              	theme_bw()
	
its2NmdsPlot = its2NmdsPlotA + 
               theme(axis.title.x = element_text(color = "black", size = 12),
              	     axis.text.x = element_blank(),
              	     axis.ticks.x = element_blank(),
              	     axis.title.y = element_text(color = "black", size = 12),
              	     axis.text.y = element_blank(),
              	     axis.ticks.y = element_blank(),
              	     legend.position = "right",
              	     legend.title = element_text(color = "black", size = 12),
              	     legend.text = element_text(color = "black", size = 12),
              	     legend.key = element_blank(),
              	     legend.background = element_blank(),
              	     panel.border = element_rect(color = "black", size = 1.2),
              	     panel.background = element_rect(fill = "white"),
              	     plot.background = element_blank()
                     )

its2NmdsPlot
```
<br>

##Saving nMDS plot
```{r, save nmds, results = 'hide'}
ggsave("nMDS_ITS2_OTU.eps", plot = its2NmdsPlot, width = 8, height = 5, dpi = 600,
       device = "eps")
```

```{r, nmds plot, echo = FALSE, fig.width = 8, fig.height = 5, fig.align = 'center'}
plot(its2NmdsPlot)
```
<br>

##Remove outlying samples
Samples with the C3g types skewing the data:
42, 80, 104, 98, 20, 57, 149, 152, 58, 163
let's look at these samples specifically
```{r, outliers}
itsOuts = its2Norm[its2Norm$sample %in% c("42", "80", "104", "98", "20", "57", 
                                          "149", "152", "58", "163"), ]
itsOuts$sums = apply(itsOuts[,4:13], 1, function(x) sum(x))
itsNoOut = its2Norm 
itsNoOut <- itsNoOut[!itsNoOut$sample %in% c("42", "80", "104", "98", "20", "57",
                                             "149", "152", "58", "163"), ]
itsNoOut$sums <- apply(itsNoOut[,4:13], 1, function(x) sum(x))

itsOuts

max(itsOuts$sum)
max(itsNoOut$sum)
mean(itsNoOut$sum)
summary(itsOuts$sum)
summary(itsNoOut$sum)
```
Nothing unusual here, neither the highest nor the lowest sequencing depth of all samples
<br>

##nMDS without outlying samples
Same idea as above, just with the new data lacking 10 C3g dominated samples. This way we can see if these samples are skewing our plot and obscuring a larger pattern in rest of the data.
```{r, nmds no outliers, results = 'hide', fig.show = 'hide'}
set.seed(694)

its2Nmds2 = metaMDS(itsNoOut[4:ncol(itsNoOut)], try = 50)
its2Nmds2

its2Scores2 = as.data.frame(scores(its2Nmds2))
its2Scores2$site = factor(itsNoOut$Site)
its2Scores2$depth = as.factor(itsNoOut$Depth)
its2Scores2$sample = row.names(its2Scores2)
head(its2Scores2)

its2Clades2 = as.data.frame(scores(its2Nmds2,"species"))
its2Clades2$seq = row.names(its2Clades2)
its2Clades2
its2Clades2$seq

## Plot the data
its2NmdsPlotB = ggplot() + 
                geom_point(data = its2Scores2, aes(x = NMDS1, y = NMDS2, 
                           shape = depth, size = depth, fill = site), 
                           color = "black") + # add the site points	
                scale_fill_manual(values = its2ColPal[c(8,5,3,9)], name = 
                                  "Reef Site",labels = c("Tobacco Reef", 
                                  "Raph's Wall", "South Reef", "Glover's Reef")) +
                scale_shape_manual(values = c(24, 23, 22, 21), name = "Depth", 
                                   labels = c("10 m", "16 m", "25 m", "35 m")) +
                scale_size_manual(values = c(3, 3.75, 3.75, 3.75)) + 
                guides(shape = guide_legend( override.aes = list(size = 
                       c(3, 3.75, 3.75, 3.75), fill = "white")), fill = 
                       guide_legend(override.aes = list(shape = 22, size = 3.75,
                       color = NA)), size = FALSE)+
                geom_text(data = its2Clades2, aes(x = NMDS1, y = NMDS2, 
                          label = seq), color = "#000000", size = 4, 
                          fontface = "italic") + 
                          # add seq labels	
                annotate("label", x = 0.95, y = 1.17, label = paste 
                         ("Distance = Bray-Curtis\nStress = ", 
                         round(its2Nmds2$stress, 4), sep = ""), size = 4) +
                labs(x = "nMDS1", y = "nMDS2") +
                coord_equal() +
                theme_bw()

its2NmdsPlot2 = its2NmdsPlotB + 
                theme(axis.title.x = element_text(color = "black", size = 12),
                      axis.text.x = element_blank(),
                      axis.ticks.x = element_blank(),
                      axis.title.y = element_text(color = "black", size = 12),
                      axis.text.y = element_blank(),
                      axis.ticks.y = element_blank(),
                      legend.position = "right",
                      legend.title = element_text(color = "black", size = 12),
                      legend.text = element_text(color = "black", size = 12),
                      legend.key = element_blank(),
                      legend.background = element_blank(),
                      panel.border = element_rect(color = "black", size = 1.2),
                      panel.background = element_rect(fill = "white"),
                      plot.background = element_blank()
                      )

its2NmdsPlot2

# saving new nMDS plot
ggsave("nMDS_ASVs_noOut.eps", plot = its2NmdsPlot2, width = 9.2, height = 5.75, 
       dpi = 600, device = "eps")
```

```{r, plot new nmds, echo = FALSE, fig.align = 'center', fig.width = 9.2, fig.height = 5.75}
plot(its2NmdsPlot2)
```
Here we can see that there is not a larger pattern in the data that was being masked by the C3g dominant samples
<br><br>

#Relative abundance of Symbiodiniaceae OTUs
Now we can calculate the relative abundance of each unique OTU per sample. This will allow us to view the community structure in a faceted barplot.
<br>

## Caluculate OTU relative abundances 
```{r, otu relative abbundance}
head(its2Norm)

its2NormPerc = its2Norm
its2NormPerc$sum = apply(its2NormPerc[, c(4:length(its2NormPerc[1,]))], 1, function(x) {
  sum(x, na.rm = T)
})	

its2NormPerc = cbind(its2NormPerc[, c(1:3)], (its2NormPerc[, 
                     c(4:(ncol(its2NormPerc)-1))] / its2NormPerc$sum))
head(its2NormPerc)
```
<br>

Now a quick sanity check. If this worked the sum of each row should = 100% (i.e. "1")
```{r, sanity check}
# test that all are now 100% = 1
apply(its2NormPerc[, c(4:(ncol(its2NormPerc)))], 1, function(x) {
  sum(x, na.rm = T)
})
```
Everything adds up to 1, this is good! The code works.
<br>

##Add plot order to data frame
I added an additional column to sort better for the stacked barplot. This was just a work around to get the ```facet_grid()``` function to play nice with our data. I added a coulumn "barPlotOrder" and for each population I filled in a series 1:n foreach sample at each Site:Depth combo, so now there's no large blank expanses on the plot.
```{r, add plot order to df}
its2ra = its2NormPerc
sampleCounts = plyr::count(its2ra, c('Site','Depth'))
meltedList = melt(lapply(sampleCounts$freq,function(x){c(1:x)}))
its2ra$barPlotOrder = meltedList$value
colnames(its2ra)[c(5:ncol(its2ra)-1)] = c("sq01_C3", "sq10_C3", "sq11_C3g","sq14_C3g", "sq17_C3g", 
                                          "sq18_C3g", "sq25_C3g", "sq05_C3z", "sq07_C3e", 
                                          "sq08_C3g")
its2ra=its2ra[c(1,ncol(its2ra),2:(ncol(its2ra)-1))]
head(its2ra)
```
<br>

##Create OTU stack for plotting
Stack the OTU data and adjust columns and factor names for plotting
```{r, otu stack}
gss = otuStack(its2ra, count.columns = c(5:length(its2ra[1, ])),
               condition.columns = c(1:4))[1:2330,] # remove summ rows

levels(gss$otu)
gss$otu = factor(gss$otu, levels(gss$otu)[c(1:8, 11, 9, 10)])
levels(gss$otu)

levels(gss$Depth)
levels(gss$Depth) = c("10 m", "16 m", "25 m", "35 m")
levels(gss$Site)
levels(gss$Site) = c("Tobacco Reef", "Raph's Wall", "South Reef", "Glover's Reef")
levels(gss$Depth)
levels(gss$Site)
```
<br>

##Consruct OTU barplot
```{r, otu barplot, fig.show = 'hide'}
OTUplotA = ggplot(gss, aes(x = barPlotOrder, y = count, fill = factor(otu))) +
          geom_bar(position = "stack", stat = "identity", color = "black",
                   size = 0.25) + 
        	ylab("Normalized proportion") +
        	scale_fill_manual(values=its2ColPal)+ 
        	labs(fill = "OTU_Clade type") +
	        facet_grid(Depth ~ Site, scales = "free_x") + #faceting plots by Depth and Site
	        theme_bw()
		  
OTUplot = OTUplotA +
          theme(axis.title.x = element_blank(),
                axis.text.x = element_blank(),
                axis.ticks.x = element_blank(),
                axis.title.y = element_text(color = "black", size = 12),
                axis.text.y = element_text(color = "black", size = 12),
                legend.position = "right",
                legend.title = element_text(color = "black", size = 12),
                legend.text = element_text(color = "black", size = 12),
                legend.key = element_blank(),
                legend.background = element_blank(),
                panel.border = element_blank(),
                panel.background = element_rect(fill = "white"),
                plot.background = element_blank(),
                strip.text.x = element_text(size = 12),
                strip.text.y = element_text(size = 12),
                strip.background = element_rect(fill = "white", size = 0.9)
                )

OTUplot
```
<br>

##Save the OTU barplot
```{r, save barplot, results = 'hide'}
ggsave("OTUbarPlot2.eps", plot = OTUplot, width = 8, height = 6, unit = "in", 
       dpi = 600)
```

```{r, otuplot, echo = FALSE, fig.width = 8, fig.height = 6, fig.align = 'center'}
plot(OTUplot)
```
<br><br>

#*ITS2* community differences
Now we can use permutational multivariate analysis of variance (PERMANOVA) to  test for differences in 
Symbiodiniaceae $\beta$-diversity across Site and Depth based on our OTUs.
<br>

##Cheking dispersion 
Using ```betadisper()``` in *vegan* to look at multivariate homogeneity of dispersion between sites and depths. This is using Bray-Curtis similarity.
```{r, betadispersion}
set.seed(694)
anova(betadisper(its2Dist, its2Norm$Depth))
```
Dispersion is heteroschedastic, but PERMANOVA is robust to deviations in 
homgeneity of variance ( Anderson and Walsh, 2013; <https://esajournals.onlinelibrary.wiley.com/doi/10.1890/12-2010.1>).
<br>

##Running PERMANOVA in R
Now let's see how different communities are from each other with PERMANOVA.
We will utilize the ```adonis()``` function in *vegan*.
We will use Bray-Curtis similarity for our distance matrix and run a total 0f 9,999 permutations, and test the effects of Site, Depth, and the interaction between Site and Depth.
```{r, permanova}
set.seed(694)
its2Adonis = adonis(its2Norm[, c(4:ncol(its2Norm))] ~ Depth*Site, 
                     data = its2Norm, permutations = 9999, method = "bray")
its2Adonis
```
We see that **Depth** has a signifcant effect on Symbiodiniaceae community structure in our *M. cavernosa* samples.
<br>

##Pairwise PERMANOVA for multiple comparisons
Since we found that Depth was a significant factor in our PERMANOVA we can now use pairwise PERMANOVA to reveal where differences occur across depth.
This utilizes the package *pairwiseAdonis*, where we will again use Bray-Curtis similarity and 9,999 permutations. We also have added false discovery rate (FDR) corrections since we are perfoming multiple comparisons.
```{r, pairwise permanova}
set.seed(694)
its2PWAdonis = pairwise.adonis(its2Norm[, c(4:ncol(its2Norm))],
                  factors = its2Norm$Depth, sim.method = "bray", 
                  p.adjust.m = "BH", perm = 9999)
its2PWAdonis
```
We see that again see differences between our deeper (25 + 35 m) and shallower (10 + 16 m) samples.
<br>

##PERMANOVA without 35 m samples
<br>

###Subset our dataframe
First we need to remove the deep samples from the dataframe. We will use our dataframe of good OTUs, which haven't been normalized yet. This way we can calculate the normalization based on only the samples we are keeping in the analysis.
```{r, remove deep samples}
goods2 = subset(goods, !Depth=="35")
goods2[] = lapply(goods2, function(x) if(is.factor(x)) factor(x) else x)
summary(goods2)
```
<br>

###Normalize reads
We will normalize samples again, as we did with the entire dataframe orignially
```{r, normalize otus}
itsgoods2Transposed = t(goods2[, 5:length(goods2[1, ])])
itsgoods2List = DGEList(counts = itsgoods2Transposed)
head(itsgoods2List$samples)
its2Norm2 =  calcNormFactors(itsgoods2List, method = "TMM")
head(its2Norm2$samples)
its2TMM = t(cpm(its2Norm2, Normalized.lib.sizes = TRUE))
its2Norm2 = cbind(goods2[,c(2:4)], its2TMM)
head(its2Norm2)
```
<br>

###Run PERMANOVA on subset of data
```{r, permanova no deep}
set.seed(694)
its2Dist2 = vegdist(its2Norm2[, c(4:ncol(its2Norm2))], method = "bray")
anova(betadisper(its2Dist2, its2Norm2$Depth))

its2Adonis2 <- adonis(its2Norm2[, c(4:ncol(its2Norm2))] ~ Depth*Site, 
                       data = its2Norm2, permutations = 9999, method = "bray")
its2Adonis2
```
Depth is still has a significant effect on community structure
<br>

###Pairwise PERMANOVA
Let' see where differences lie across depth using pairwise permanova again.
```{r, pw permanova no deep}
set.seed(694)
its2PWAdonis2 = pairwise.adonis(its2Dist2, factors = its2Norm2$Depth,
                                perm = 9999, p.adjust.m = "BH")
its2PWAdonis2
```
The differences are still between 25 m and the shallower sites (10 + 16 m). This gives us confidence that our deeper samples aren't changing our interpretation.
<br><br>

#Generalized linear mixed model of OTUs
To see how significantly changing OTUs across depth we will use the package *MCMC.OTU*, which performs Bayesian analysis of multivariate count data.
This will create a MCMC-based GLMM analysis of our OTU data.
<br>

##Stack OTU data table
```{r, stack data table}
its2Glm = its2Norm
colnames(its2Glm)[4:ncol(its2Glm)] = c("sq01_C3", "sq10_C3", "sq11_C3g", 
                                       "sq14_C3g", "sq17_C3g", "sq18_C3g", 
                                       "sq25_C3g", "sq05_C3z", "sq07_C3e", 
                                       "sq08_C3g")
glmStack=otuStack(data=its2Glm, count.columns = c(4:ncol(its2Glm)), 
                  condition.columns=c(1:3)) 

levels(glmStack$otu)
glmStack$otu = factor(glmStack$otu, levels(glmStack$otu)[c(1:8, 11, 9, 10)])
levels(glmStack$otu)
glmStack$count = round(glmStack$count, 0)
head(glmStack)
```
<br>

##Creating the model
Now that we have our data setup correctly we can create the GLMM
<br>

###Fitting the model
Here we are using Depth as a fixed effect and running 10^6 iterations with a 5000 burn-in period.
```{r, mcmcglmm, results = 'hide', message = FALSE}
set.seed(694)
its2MmD = mcmc.otu(fixed = "Depth", data = glmStack,
                   nitt=100000, thin=25, burnin=5000)
```
<br>

###Calculate effect size and *p*-values
```{r, calculate effect size, fig.show = 'hide'}
ssD = OTUsummary(its2MmD, glmStack, summ.plot = FALSE)
ssD = padjustOTU(ssD)
sigsD = signifOTU(ssD)

ss2D = OTUsummary(its2MmD, glmStack, otus = sigsD, whiskers = "sd", 
                  ptype = "mcmc")

its2MCMCglmD = ss2D$summary
levels(its2MCMCglmD$otu)
its2MCMCglmD$Depth = as.factor(its2MCMCglmD$Depth)
its2MCMCglmD$otu = factor(its2MCMCglmD$otu, levels = c("sq01_C3", "sq10_C3",
                          "sq14_C3g", "sq17_C3g", "sq18_C3g", "sq25_C3g", 
                          "sq08_C3g", "sq07_C3e"))

ssD$otuWise[sigsD]

```
<br>

###Plotting the GLMM
We are now plotting the GLMM using our color pallete we created for the OTUs
```{r, glmm plot, fig.show = 'hide'}
pd = position_dodge(0.3)

its2glmPlotA = ggplot(its2MCMCglmD, aes(x = Depth, y = mean, group = otu, 
                      colour =otu))+
                      geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd), 
                                    lwd = 0.6, width = 0.5, 	position = pd) +
                      geom_line(aes(group = otu), lwd = 0.6, position = pd)+
                      geom_point(aes(group = otu), position = pd, size = 2.5)+
                      scale_color_manual(values = its2ColPal [c(1,2,4:8,10)], 
                                         name = "OTU_Clade type") +
                      xlab("Depth")+
                      ylab("log10(proportion)") +
                      theme_bw()

its2glmPlotD = its2glmPlotA +	
               theme(axis.title.x = element_text(color = "black", size = 12),
                     axis.text.x = element_text(color = "black", size = 12),
                     axis.title.y = element_text(color = "black", size = 12),
                     axis.text.y = element_text(color = "black", size = 12),
                     legend.position = "right",
                     legend.title = element_text(color = "black", size = 12),
                     legend.text = element_text(color = "black", size = 12),
                     legend.key = element_blank(),
                     legend.background = element_blank(),
                     panel.border = element_rect(color = "black", size = 1.2),
                     panel.background = element_rect(fill = "white"),
                     plot.background = element_blank()
                     )

its2glmPlotD
```
<br>

###Save GLMM plot
```{r, save glmm plot, results = 'hide'}
ggsave("its2glmDepth.eps", plot=its2glmPlotD, width = 8, height = 6, dpi = 600)
```

```{r, display glmm plot, echo = FALSE, fig.align = 'center', fig.width = 8, fig.height = 6, reults = 'hide'}
plot(its2glmPlotD)
```